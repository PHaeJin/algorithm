#include<iostream>
#include<vector>
#include<algorithm>
#include<utility>
#include<queue>

using namespace std;
int arr[16][16];
bool visit[16][16];
int depth[16][16];
int N, startX, startY, endX, endY;


int main()
{
	int Testcase,CountT;
	CountT = 1;
	
	cin >> Testcase;

	while (Testcase != 0)
	{
		
		cin >> N;
		for (int i = 0; i < N; i++)
		{
			for (int j = 0; j < N; j++)
			{
				cin >> arr[i][j];
				visit[i][j] = false;
				depth[i][j] = 0;
			}
		}
		cin >> startX >> startY;
		cin >> endX >> endY;

		queue<pair<int, int> > q;
		q.push(make_pair(startX, startY));
		visit[startX][startY] = true;
		depth[startX][startY] = 0;

		int time = 0;
		bool check_end = false;
		while (!q.empty())
		{
			int x = q.front().first;
			int y = q.front().second;
			int depth_m = depth[x][y];
			q.pop();
			
			if (x == endX && y == endY)
			{
				check_end = true;
				cout << "#" << CountT++ <<" "<< depth[x][y] << endl;
				break;
			}

			if (x + 1 < N && !visit[x + 1][y] && arr[x + 1][y] != 1)
			{
				if (arr[x + 1][y] == 0)
				{
					visit[x + 1][y] = true;
					depth[x + 1][y] = depth_m + 1;
					q.push(make_pair(x + 1, y));
				}
				else
				{
					if (depth_m % 3 == 2)
					{
						visit[x + 1][y] = true;
						depth[x + 1][y] = depth_m + 1;
						q.push(make_pair(x + 1, y));
					}
					else
					{
						depth[x][y] = depth_m + 1;
						q.push(make_pair(x, y));
					}
				}
			}
			if (y + 1 < N && !visit[x][y + 1] && arr[x][y + 1] != 1)
			{
				if (arr[x][y+1] == 0)
				{
					visit[x][y+1] = true;
					depth[x][y+1] = depth_m + 1;
					q.push(make_pair(x, y+1));
				}
				else
				{
					if (depth_m % 3 == 2)
					{
						visit[x][y+1] = true;
						depth[x][y+1] = depth_m + 1;
						q.push(make_pair(x, y+1));
					}
					else
					{
						depth[x][y] = depth_m + 1;
						q.push(make_pair(x, y));
					}
				}
			}
			if (x - 1 >= 0 && !visit[x - 1][y] && arr[x - 1][y] != 1)
			{
				if (arr[x-1][y] == 0)
				{
					visit[x-1][y] = true;
					depth[x-1][y] = depth_m + 1;
					q.push(make_pair(x-1, y));
				}
				else
				{
					if (depth_m % 3 == 2)
					{
						visit[x-1][y] = true;
						depth[x - 1][y] = depth_m + 1;
						q.push(make_pair(x-1, y));
					}
					else
					{
						depth[x][y] = depth_m + 1;
						q.push(make_pair(x, y));
					}
				}
			}
			if (y - 1 >= 0 && !visit[x][y - 1] && arr[x][y - 1] != 1)
			{
				if (arr[x][y - 1] == 0)
				{
					visit[x][y - 1] = true;
					depth[x][y - 1] = depth_m + 1;
					q.push(make_pair(x, y - 1));
				}
				else
				{
					if (depth_m % 3 == 2)
					{
						visit[x][y - 1] = true;
						depth[x][y - 1] = depth_m + 1;
						q.push(make_pair(x, y -1));
					}
					else
					{
						depth[x][y] = depth_m + 1;
						q.push(make_pair(x, y));
					}
				}
			}

		}

		if(!check_end)
			cout << "#" << CountT++ << " " << "-1" << endl;
		
		Testcase--;
	}
	
	return 0;
}

